Палагин Сергей, [10.11.2022 0:16]
Я тебе сейчас тут наговорю. )))
Вот этого не совсем мне понятно

Палагин Сергей, [10.11.2022 0:16]
@Component
@Getter
@Setter
@Slf4j
public abstract class BotMessenger {

Палагин Сергей, [10.11.2022 0:19]
Абстрактный класс предполагает, что экземпляров этого класса быть не может.
В то же самое время @Component предполагает, что спринг инжектирует экземпляр этого класса куда-то.

Палагин Сергей, [10.11.2022 0:19]
Две взаимоисключающие вещи

Палагин Сергей, [10.11.2022 0:23]
2. Репозитории лучше инжектировать с модификатором final. И убрать конструктор, добавить аннотацию ломбока @RequiredArgsConstructor.

Палагин Сергей, [10.11.2022 0:25]
и лучше его сделать private. Эта аннотация создаст конструктор из финальных переменных

Палагин Сергей, [10.11.2022 0:25]
Код станет чище

Палагин Сергей, [10.11.2022 0:26]
Может вот это лучше вынести в интерфейс отдельный?
    public abstract boolean isAllow();
    public abstract boolean isExclusive();
    public abstract SendMessage execute();
    public abstract boolean isAdmin();

Палагин Сергей, [10.11.2022 0:29]
Дизайн класса как-то не нравится. Сейчас объясню, что не так

Палагин Сергей, [10.11.2022 0:32]
Смотри, какие есть проблемы в классе.

Палагин Сергей, [10.11.2022 0:33]
Я просто глубоко еще не погружался в саму функциональность, возможно я не прав. Просто имей ввиду, что такое может быть

Палагин Сергей, [10.11.2022 0:34]
Мне не нравится использование переменных протектед у тебя.

Палагин Сергей, [10.11.2022 0:36]
Вот смотри - если ты поставил @component, то предполгаешь что экземпляры этого класса(наследников, поскольку это абстрактный класс) будут инжектироваться спрингом

Палагин Сергей, [10.11.2022 0:36]
1. Компонент тут не нужен. Самый лучший код - ненаписанный)

Палагин Сергей, [10.11.2022 0:40]
2. Переменные протектед предполагают использование их в наследниках и этом классе. Тут же стоит @Getter на классе, который пртведет к созданию public метода getFoo(); т.е. протектед скрывает его от внешнего воздействия, но появляется геттер публичный, который его достает. Зачем тогда протектед, когда можно приват сделать. Все равно по @getter он будет доступен и наследникам и  другим классам

Палагин Сергей, [10.11.2022 0:40]
Тут я вижу какую то принципиальную ошибку использования модификаторов доступа

Палагин Сергей, [10.11.2022 0:44]
3. Перекрытие методов

Палагин Сергей, [10.11.2022 0:46]
Ломбок @Getter
В сочетании с
protected   Message message;
дадут метод getMessage();

Палагин Сергей, [10.11.2022 0:46]
Но ты его перекрываешь своим без зазрения совести
    public Message getMessage(){
        return update.getMessage();
    }

Палагин Сергей, [10.11.2022 0:48]
Во первых @Getter даст тебе прямой доступ к update через getUpdate().getMessage()

Палагин Сергей, [10.11.2022 0:49]
Начинает возникать путаница - что есть message? Это update.getMessage() или просто message.

Палагин Сергей, [10.11.2022 0:51]
4. Самая скрытая ошибка. Скоуп этих переменных:
    protected   Update update;
    protected   Message message;

Палагин Сергей, [10.11.2022 0:52]
@Component предполагает, что будет синглтон.

Палагин Сергей, [10.11.2022 0:52]
Если ничего не указывать

Палагин Сергей, [10.11.2022 0:52]
другого

Палагин Сергей, [10.11.2022 0:53]
Т.е. у тебя класс, помеченный @Component(с учетом вышесказанного, я предполагаю, что компонент будет на наследниках)

Палагин Сергей, [10.11.2022 0:54]
А не на абстракном классе

Палагин Сергей, [10.11.2022 0:55]
Т.е. что получается с точки зрения многопоточности..

Палагин Сергей, [10.11.2022 0:55]
Наследник у тебя всегда один в системе, кто бы не обратился

Палагин Сергей, [10.11.2022 0:55]
к нему

Палагин Сергей, [10.11.2022 0:55]
Инстанс наследника т.е.

Палагин Сергей, [10.11.2022 0:56]
А как я понимаю, к боту будут обращаться паралельно неограниченное число лиц

Палагин Сергей, [10.11.2022 0:56]
А тут у тебя ссылка на один и тот же класс
    protected   Update update;
    protected   Message message;
    protected   UserRepository userRepository;

Палагин Сергей, [10.11.2022 0:57]
Если вот это вот предполагает изменение
    protected   Update update;
    protected   Message message;
то алгоритм будет работать неверно. Будет что-то типа мусорных переменных или состояние гонки

Палагин Сергей, [10.11.2022 0:58]
Т.е. разные боты будут читать и писать в несинхронизированную переменную, изменяя состояние объекта произвольно

Палагин Сергей, [10.11.2022 0:59]
И ты будешь видеть как все хорошо, так и полный трешь

Палагин Сергей, [10.11.2022 0:59]
зависит от случайности обращения к этим переменным

Палагин Сергей, [10.11.2022 1:00]
Т..е вот одна сессия в переменную загнала своего юзера, а вторая в это время читает его

Палагин Сергей, [10.11.2022 1:00]
Вот тут
    public void saveUser(){
        if(userRepository.findById(update.getMessage().getChatId()).isEmpty()){
            User user = new User();
            user.setId(update.getMessage().getChatId());
            user.setUserName(update.getMessage().getChat().getUserName());
            user.setFirstName(update.getMessage().getChat().getFirstName());
            user.setLastName(update.getMessage().getChat().getLastName());
            user.setDateReg(new Timestamp(System.currentTimeMillis()));
            user = userRepository.save(user);
            log.info("Add user with id={}, firstName={}, lastName={}, userName={}", user.getId(), user.getFirstName(), user.getLastName(), user.getUserName());
        }

    }

Палагин Сергей, [10.11.2022 1:02]
Где-то там мессага изменяется у тебя в глубине. Как я понимаю, неверно хранить это в протектед переменных в этом классе и синхронизация не выход. Должен быть отдельный контекст именно этого юзера, работающего с ботом.

Палагин Сергей, [10.11.2022 1:06]
Ради интереса, настрой jmeter какой-нить и пусти параллельно 1000 потоков в бот

Палагин Сергей, [10.11.2022 1:06]
и посмотри, что они писать будут

Палагин Сергей, [10.11.2022 1:06]
в базу

Палагин Сергей, [10.11.2022 1:07]
На протяжении 5 минут

Палагин Сергей, [10.11.2022 1:10]
Мне нравится твой стиль названия переменных. У меня как-то так не получается. У меня большие переменные